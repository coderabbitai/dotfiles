syntax on
filetype plugin indent on

" add a new filetype to map zshXXXXXX files to zsh
au BufNewFile,BufRead *.zsh* set filetype=zsh


"Use 24-bit (true-color) mode in Vim/Neovim
if (has('nvim'))
  "For Neovim 0.1.3 and 0.1.4 < https://github.com/neovim/neovim/pull/2198 >
  let $NVIM_TUI_ENABLE_TRUE_COLOR=1
endif
"For Neovim > 0.1.5 and Vim > patch 7.4.1799 < https://github.com/vim/vim/commit/61be73bb0f965a895bfb064ea3e55476ac175162 >
"Based on Vim patch 7.4.1770 (`guicolors` option) < https://github.com/vim/vim/commit/8a633e3427b47286869aa4b96f2bfc1fe65b25cd >
" < https://github.com/neovim/neovim/wiki/Following-HEAD#20160511 >
if (has('termguicolors'))
  set termguicolors
endif

" allow to scroll in the preview and other actions
set mouse=a

" enable mousemoveevent
set mousemoveevent

set number

set tabstop=2       " The width of a TAB is set to 4.
" Still it is a \t. It is just that
" Vim will interpret it to be having
" a width of 4.

set shiftwidth=2    " Indents will have a width of 4

set softtabstop=2   " Sets the number of columns for a TAB

set expandtab       " Expand TABs to spaces

set ignorecase

set smartcase

" use system clipboard
if has('nvim')
  set clipboard+=unnamedplus
else
  set clipboard^=unnamed,unnamedplus
endif
    
vmap <C-c> "+y

let mapleader='\\'
map <Leader> <Plug>(easymotion-prefix)

if exists('$TMUX')
  let g:last_tmux_uuid=system('tmux show-environment -g TMUX_UUID  2> /dev/null')
  " autocmd to check of uuid changes and prompt user if they want
  autocmd FocusGained * let tmux_uuid=system('tmux show-environment -g TMUX_UUID  2> /dev/null') | if g:last_tmux_uuid != tmux_uuid  | let g:last_tmux_uuid=tmux_uuid | let cfm=confirm("Autoupdate detected, reload .vimrc?", "&Yes\n&No", 1) | if cfm == 1 | source $MYVIMRC | endif | endif
endif

" For Git plugin
set diffopt+=vertical

let g:fuzzymenu_vim_config = '~/.vimrc_local'

" use vim-plug
augroup vimplug
  let data_dir = has('nvim') ? stdpath('data') . '/site' : '~/.vim'
  if empty(glob(data_dir . '/autoload/plug.vim'))
    silent execute '!curl -fLo '.data_dir.'/autoload/plug.vim --create-dirs  https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim'
    autocmd VimEnter * PlugInstall --sync | source $MYVIMRC
  endif
augroup end

call plug#begin('~/.vim/plugged')

" source user provided plugins from ~/.vimrc_plugins
if filereadable(expand('~/.vimrc_plugins'))
  source ~/.vimrc_plugins
endif

Plug 'tpope/vim-sensible'
Plug 'tveskag/nvim-blame-line'
Plug 'neoclide/coc.nvim', {'branch': 'release'}

Plug 'vim-airline/vim-airline'
Plug 'tpope/vim-fugitive'
Plug 'github/copilot.vim'
Plug 'junegunn/fzf'
Plug 'junegunn/fzf.vim'
Plug 'tpope/vim-rhubarb'
Plug 'mhinz/vim-startify'
Plug 'harjotgill/fuzzy-menu.vim'
Plug 'prabirshrestha/async.vim'
Plug 'laher/gothx.vim', {'for': 'go'}
Plug 'maralla/gomod.vim', {'for': 'gomod'}
Plug 'antoinemadec/coc-fzf'
Plug 'voldikss/vim-floaterm'
Plug 'voldikss/fzf-floaterm'
Plug 'voldikss/coc-floaterm'
Plug 'tpope/vim-commentary'
Plug 'samoshkin/vim-mergetool'
Plug 'chrisbra/Recover.vim'
Plug 'Yggdroot/indentLine'
Plug 'simnalamburt/vim-mundo'
Plug 'tyru/open-browser.vim'
Plug 'tjdevries/coc-zsh'
Plug 'aacunningham/vim-fuzzy-stash'
Plug 'easymotion/vim-easymotion'
Plug 'powerman/vim-plugin-AnsiEsc'
Plug 'chrisbra/unicode.vim'
Plug 'mracos/mermaid.vim'
Plug 'google/vim-jsonnet'
Plug 'gelguy/wilder.nvim'
Plug 'prisma/vim-prisma'

" colors
Plug 'sainnhe/gruvbox-material'
Plug 'sainnhe/everforest'
Plug 'sainnhe/edge'
Plug 'sainnhe/sonokai'
Plug 'EdenEast/nightfox.nvim'
Plug 'joshdick/onedark.vim'
Plug 'cocopon/iceberg.vim'
Plug 'mhartington/oceanic-next'
Plug 'folke/tokyonight.nvim'
Plug 'arcticicestudio/nord-vim'
Plug 'jacoborus/tender.vim'
Plug 'whatyouhide/vim-gotham'
Plug 'Everblush/everblush.vim'

" add nvim specific plugins below
Plug 'equalsraf/neovim-gui-shim', has('nvim') && !has('gui_vimr') ? {} : { 'on': [] }
Plug 'pwntester/octo.nvim', has('nvim') ? {} : { 'on': [] }
Plug 'nvim-lua/plenary.nvim', has('nvim') ? {} : { 'on': [] }
Plug 'MunifTanjim/nui.nvim', has('nvim') ? {} : { 'on': [] }
Plug 'nvim-telescope/telescope.nvim', has('nvim') ? {} : { 'on': [] }
Plug 'nvim-telescope/telescope-fzf-native.nvim', has('nvim') ? { 'do': 'make' } : { 'on': [] }
Plug 'nvim-telescope/telescope-symbols.nvim', has('nvim') ? {} : { 'on': [] }
Plug 'rcarriga/nvim-notify', has('nvim') ? {} : { 'on': [] }
Plug 'nvim-treesitter/nvim-treesitter', has('nvim') ? {'do': ':TSUpdate'} : { 'on': [] }
Plug 'SirVer/ultisnips', has('nvim') ? {} : { 'on': [] }
Plug 'honza/vim-snippets', has('nvim') ? {} : { 'on': [] }
Plug 'nvim-tree/nvim-web-devicons', has('nvim') ? {} : { 'on': [] }
Plug 'akinsho/bufferline.nvim', has('nvim') ? {} : { 'on': [] }
Plug 'stevearc/dressing.nvim', has('nvim') ? {} : { 'on': [] }
Plug 'lewis6991/gitsigns.nvim', has('nvim') ? {} : { 'on': [] }
Plug 'kevinhwang91/nvim-hlslens', has('nvim') ? {} : { 'on': [] }
Plug 'petertriho/nvim-scrollbar', has('nvim') ? {} : { 'on': [] }
Plug 'otavioschwanck/tmux-awesome-manager.nvim', has('nvim') ? {} : { 'on': [] }
Plug 'chrisgrieser/nvim-early-retirement', has('nvim') ? {} : { 'on': [] }

if exists('$OPENAI_API_KEY')
  Plug 'dpayne/CodeGPT.nvim', has('nvim') ? {} : { 'on': [] }
endif

if !has('nvim')
  " Wilder
  Plug 'roxma/nvim-yarp'
  Plug 'roxma/vim-hug-neovim-rpc'
endif

Plug 'ryanoasis/vim-devicons'

" Initialize plugin system
call plug#end()

" Run PlugInstall if there are missing plugins
if len(filter(values(g:plugs), '!isdirectory(v:val.dir)'))
  PlugInstall --sync
endif

" unset wildmenu
set nowildmenu

" Wilder
" Default keys
call wilder#setup({
      \ 'modes': [':', '/', '?'],
      \ 'next_key': '<Tab>',
      \ 'previous_key': '<S-Tab>',
      \ 'accept_key': '<Down>',
      \ 'reject_key': '<Up>',
      \ })

call wilder#set_option('renderer', wilder#popupmenu_renderer(wilder#popupmenu_border_theme({
      \ 'border': 'single',
      \ 'highlighter': wilder#basic_highlighter(),
      \ 'highlights': {
      \   'border': 'Normal',
      \   'accent': wilder#make_hl('WilderAccent', 'Pmenu', [{}, {}, {'foreground': '#F06929'}]),  
      \ },
      \ 'left': [
      \   ' ', wilder#popupmenu_devicons(),
      \ ],
      \ 'right': [
      \   ' ', wilder#popupmenu_scrollbar(),
      \ ],
      \ })))

call wilder#set_option('pipeline', [
      \   wilder#branch(
      \     wilder#cmdline_pipeline({
      \       'language': 'python',
      \       'fuzzy': 1,
      \     }),
      \     wilder#python_search_pipeline({
      \       'pattern': wilder#python_fuzzy_pattern(),
      \       'sorter': wilder#python_difflib_sorter(),
      \       'engine': 're',
      \     }),
      \   ),
      \ ])

" copilot enable for markdown files
let g:copilot_filetypes = {
    \ 'markdown': v:true,
    \ }

" disable coc status in airline as it is shown with nvim-notify
if has("nvim")
  let g:airline#extensions#coc#show_coc_status = 0
else
  let g:airline#extensions#tabline#enabled = 1
  let g:airline#extensions#tabline#show_buffers = 0
  let g:airline#extensions#tabline#show_tab_count = 1
  let g:airline#extensions#tabline#tab_nr_type = 1
  let g:airline_powerline_fonts = 1
endif

let airline#extensions#coc#error_symbol = ''
let airline#extensions#coc#warning_symbol = ''

let g:airline#extensions#whitespace#enabled = 0
let g:airline#extensions#hunks#enabled = 1
let g:airline#extensions#hunks#non_zero_only = 1

let g:gothx_command_prefix = 'Go'

let g:indentLine_fileTypeExclude = ['startify', 'floaterm', 'coc-explorer', 'coctree', 'json']

" avoid for markdown as it sets the conceallevel to 2
autocmd FileType markdown let g:indentLine_enabled=0

" turn on gitblame by default
autocmd BufEnter * EnableBlameLine

" install coc extensions
let g:coc_global_extensions = [
      \ 'coc-highlight', 
      \ 'coc-go', 
      \ 'coc-explorer', 
      \ 'coc-pairs', 
      \ 'coc-yank', 
      \ 'coc-vale',
      \ 'coc-html',
      \ 'coc-yaml',
      \ 'coc-sql',
      \ 'coc-pyright',
      \ 'coc-json',
      \ 'coc-clangd',
      \ 'coc-webview',
      \ 'coc-markdown-preview-enhanced',
      \ 'coc-markdownlint',
      \ 'coc-reveal',
      \ 'coc-swagger',
      \ 'coc-toml',
      \ 'coc-markmap', 
      \ 'coc-diagnostic',
      \ 'coc-prettier',
      \ 'coc-marketplace',
      \ 'coc-vimlsp',
      \ 'coc-protobuf',
      \ 'coc-postfix',
      \ 'coc-tsserver',
      \ 'coc-eslint',
      \ 'coc-lua',
      \ 'coc-snippets',
      \ 'coc-ltex',
      \ 'coc-symbol-line',
      \ 'coc-java',
      \ 'coc-spell-checker',
      \ 'coc-prisma'
      \ ]

augroup buffer_keymaps
  autocmd FileType gitcommit inoremap<buffer><silent> @ @<C-x><C-o>
  autocmd FileType gitcommit inoremap<buffer><silent> # #<C-x><C-o>
augroup end

" some utility functions
" Like windo but restore the current window.
function! WinDo(command)
  let currwin=winnr()
  let curaltwin=winnr('#')
  execute 'windo ' . a:command
  " restore previous/alt window
  execute curaltwin . 'wincmd w'
  " restore current window
  execute currwin . 'wincmd w'
endfunction
com! -nargs=+ -complete=command Windo call WinDo(<q-args>)

" Like bufdo but restore the current buffer.
function! BufDo(command)
  let currBuff=bufnr('%')
  execute 'bufdo ' . a:command
  execute 'buffer ' . currBuff
endfunction
com! -nargs=+ -complete=command Bufdo call BufDo(<q-args>)

" Like tabdo but restore the current tab.
function! TabDo(command)
  let currTab=tabpagenr()
  execute 'tabdo ' . a:command
  execute 'tabn ' . currTab
endfunction
com! -nargs=+ -complete=command Tabdo call TabDo(<q-args>)

command! -complete=shellcmd -nargs=+ Shell call s:RunShellCommand(<q-args>)
function! s:RunShellCommand(cmdline)
  echo a:cmdline
  let expanded_cmdline = a:cmdline
  for part in split(a:cmdline, ' ')
     if part[0] =~ '\v[%#<]'
        let expanded_part = fnameescape(expand(part))
        let expanded_cmdline = substitute(expanded_cmdline, part, expanded_part, '')
     endif
  endfor
  botright new
  setlocal buftype=nofile bufhidden=wipe nobuflisted noswapfile nowrap
  call setline(1, 'You entered:    ' . a:cmdline)
  call setline(2, 'Expanded Form:  ' .expanded_cmdline)
  call setline(3,substitute(getline(2),'.','=','g'))
  execute '$read !'. expanded_cmdline
  setlocal nomodifiable
  1
endfunction

" Use ctrl-[hjkl] to select the active split window.
nmap <silent> <c-k> :wincmd k<CR>
nmap <silent> <c-j> :wincmd j<CR>
nmap <silent> <c-h> :wincmd h<CR>
nmap <silent> <c-l> :wincmd l<CR>

"" Coc.vim config follows

" Set internal encoding of vim, not needed on neovim, since coc.nvim using some
" unicode characters in the file autoload/float.vim
set encoding=UTF-8

" Some servers have issues with backup files, see #649.
set nobackup
set nowritebackup

" Having longer updatetime (default is 4000 ms = 4 s) leads to noticeable
" delays and poor user experience.
set updatetime=300

" Always show the signcolumn, otherwise it would shift the text each time
" diagnostics appear/become resolved.
set signcolumn=yes

" Use tab for trigger completion with characters ahead and navigate.
" NOTE: Use command ':verbose imap <tab>' to make sure tab is not mapped by
" other plugin before putting this into your config.
" inoremap <silent><expr> <TAB>
"       \ coc#pum#visible() ? coc#pum#next(1):
"       \ CheckBackspace() ? "\<Tab>" :
"       \ coc#refresh()
" inoremap <expr><S-TAB> coc#pum#visible() ? coc#pum#prev(1) : "\<C-h>"

" Make <CR> to accept selected completion item or notify coc.nvim to format
" <C-g>u breaks current undo, please make your own choice.
inoremap <silent><expr> <CR> coc#pum#visible() ? coc#pum#confirm()
                              \: "\<C-g>u\<CR>\<c-r>=coc#on_enter()\<CR>"

function! CheckBackspace() abort
  let col = col('.') - 1
  return !col || getline('.')[col - 1]  =~# '\s'
endfunction

" Use <c-space> to trigger completion.
if has('nvim')
  inoremap <silent><expr> <c-space> coc#refresh()
else
  inoremap <silent><expr> <c-@> coc#refresh()
endif

" Use `g[` and `g]` to navigate diagnostics
" Use `:CocDiagnostics` to get all diagnostics of current buffer in location list.
nmap <silent> g[ <Plug>(coc-diagnostic-prev)
nmap <silent> g] <Plug>(coc-diagnostic-next)

" GoTo code navigation.
nmap <silent> gd <Plug>(coc-definition)
nmap <silent> gr <Plug>(coc-references)

nmap <silent> gy <Plug>(coc-type-definition)
nmap <silent> gi <Plug>(coc-implementation)

nmap <silent> ga <Plug>(UnicodeGA)

" Use K to show documentation in preview window.
nnoremap <silent> K :call ShowDocumentation()<CR>

function! ShowDocumentation()
  if CocAction('hasProvider', 'hover')
    call CocActionAsync('doHover')
  else
    call feedkeys('K', 'in')
  endif
endfunction

" Highlight the symbol and its references when holding the cursor.
autocmd CursorHold * silent call CocActionAsync('highlight')

augroup coc_actions
  autocmd!
  " add missing go imports on save
  autocmd BufWritePre *.ts,*.js,*.go silent! call CocAction('organizeImport')
  " Setup formatexpr specified filetype(s).
  autocmd FileType typescript,json setl formatexpr=CocAction('formatSelected')
  " Update signature help on jump placeholder.
  autocmd User CocJumpPlaceholder call CocActionAsync('showSignatureHelp')
augroup end

" Symbol renaming.
nmap <space>r :CocRename<cr>

" init.vim has CocRename defined for nvim
if !has('nvim')
  " make a CocRename command that calls CocActionAsync('rename')
  command CocRename call CocActionAsync('rename')
endif

" Formatting selected code.
xmap <space>f  <Plug>(coc-format-selected)
nmap <space>f  <Plug>(coc-format-selected)

nnoremap <silent> <space>y  :<C-u>CocFzfList yank<cr>

" Applying codeAction to the cursor
xmap <space>a  <Plug>(coc-codeaction-cursor)
nmap <space>a  <Plug>(coc-codeaction-cursor)

" Codelens
xmap <space>l  <Plug>(coc-codelens-action)
nmap <space>l  <Plug>(coc-codelens-action)

" Apply AutoFix to problem on the current line.
nmap <space>qf  <Plug>(coc-fix-current)

" Map function and class text objects
" NOTE: Requires 'textDocument.documentSymbol' support from the language server.
xmap if <Plug>(coc-funcobj-i)
omap if <Plug>(coc-funcobj-i)
xmap af <Plug>(coc-funcobj-a)
omap af <Plug>(coc-funcobj-a)
xmap ic <Plug>(coc-classobj-i)
omap ic <Plug>(coc-classobj-i)
xmap ac <Plug>(coc-classobj-a)
omap ac <Plug>(coc-classobj-a)

" Remap <C-f> and <C-b> for scroll float windows/popups.
if has('nvim-0.4.0') || has('patch-8.2.0750')
  nnoremap <silent><nowait><expr> <C-f> coc#float#has_scroll() ? coc#float#scroll(1) : "\<C-f>"
  nnoremap <silent><nowait><expr> <C-b> coc#float#has_scroll() ? coc#float#scroll(0) : "\<C-b>"
  inoremap <silent><nowait><expr> <C-f> coc#float#has_scroll() ? "\<c-r>=coc#float#scroll(1)\<cr>" : "\<Right>"
  inoremap <silent><nowait><expr> <C-b> coc#float#has_scroll() ? "\<c-r>=coc#float#scroll(0)\<cr>" : "\<Left>"
  vnoremap <silent><nowait><expr> <C-f> coc#float#has_scroll() ? coc#float#scroll(1) : "\<C-f>"
  vnoremap <silent><nowait><expr> <C-b> coc#float#has_scroll() ? coc#float#scroll(0) : "\<C-b>"
endif

" Use CTRL-S for selections ranges.
" Requires 'textDocument/selectionRange' support of language server.
nmap <silent> <C-s> <Plug>(coc-range-select)
xmap <silent> <C-s> <Plug>(coc-range-select)

" Add `:Format` command to format current buffer.
command! -nargs=0 Format :call CocAction('format')

" Add `:Fold` command to fold current buffer.
command! -nargs=? Fold :call     CocAction('fold', <f-args>)

" Add `:OR` command for organize imports of the current buffer.
command! -nargs=0 OR   :call     CocActionAsync('runCommand', 'editor.action.organizeImport')

" Mappings for CoCList
" Do default action for next item.
nnoremap <silent><nowait> <space>j  :<C-u>CocNext<CR>
" Do default action for previous item.
nnoremap <silent><nowait> <space>k  :<C-u>CocPrev<CR>

function! OutlineToggle() 
  if get(b:,'coc_outline_visible',0) == 0
    call CocActionAsync('showOutline', 1)
    let b:coc_outline_visible = 1
  else
    call CocAction('hideOutline')
    let b:coc_outline_visible = 0
  endif
endfunction

nnoremap <silent> <space>o :call OutlineToggle()<CR>

nmap <space>e <Cmd>CocCommand explorer<CR>

let g:diagnostic_window_size = 3

" open diagnostics
xmap <silent> <space>d :call ToggleDiagnostics()<CR>
nmap <silent> <space>d :call ToggleDiagnostics()<CR>

function! ToggleDiagnostics() abort
  execute 'CocList --height=5 diagnostics --buffer'
endfunction

augroup coc_nvim
  " shutdown coc on exit
  autocmd VimLeavePre * :call coc#rpc#kill() 
  " auto close outline if it's the last window
  autocmd BufEnter * call s:CheckDanglingWindows()
  function! s:CheckDanglingWindows() abort
    if ((&filetype ==# 'coctree' 
          \ || &filetype ==# 'coc-explorer'
          \ || &filetype ==# 'Mundo'
          \ || &filetype ==# 'MundoDiff'
          \ || &filetype ==# 'qf'
          \) && winnr('$') == 1)
      if tabpagenr('$') != 1
        close
      else
        bdelete
      endif
    endif
  endfunction
augroup end

" Remove plugins not explicitly defined in g:coc_global_extensions
function! CocExtClean() abort
  let g:extensions_to_clean = CocAction("loadedExtensions")
      \ ->filter({idx, extension -> extension !~ 'coc-vim-source-zsh'})
      \ ->filter({idx, extension -> index(g:coc_global_extensions, extension) == -1})
  if len(g:extensions_to_clean)
    exe 'CocUninstall' join(map(g:extensions_to_clean, {_, line -> split(line)[0]}))
  endif
endfunction
command! -nargs=0 CocExtClean :call CocExtClean()

autocmd User CocNvimInit call timer_start(250, {-> CocExtClean()})

" it uses the <tab> which copilot uses
let g:UltiSnipsExpandTrigger="<C-l>"

" FZF 
" An action can be a reference to a function that processes selected lines
function! s:build_quickfix_list(lines)
  call setqflist(map(copy(a:lines), '{ "filename": v:val }'))
  copen
  cc
endfunction

let g:fzf_action = {
      \ 'ctrl-q': function('s:build_quickfix_list'),
      \ 'ctrl-t': 'tab split',
      \ 'ctrl-x': 'split',
      \ 'ctrl-v': 'vsplit' }

" - Popup window (center of the current window)
let g:fzf_layout = { 'window': { 'width': 0.9, 'height': 0.9, 'relative': v:true } }

" Customize fzf colors to match your color scheme
" - fzf#wrap translates this to a set of `--color` options
let g:fzf_colors =
      \ { 'fg':      ['fg', 'Normal'],
      \ 'bg':      ['bg', 'Normal'],
      \ 'hl':      ['fg', 'Comment'],
      \ 'fg+':     ['fg', 'CursorLine', 'CursorColumn', 'Normal'],
      \ 'bg+':     ['bg', 'CursorLine', 'CursorColumn'],
      \ 'hl+':     ['fg', 'Statement'],
      \ 'info':    ['fg', 'PreProc'],
      \ 'border':  ['fg', 'Ignore'],
      \ 'prompt':  ['fg', 'Conditional'],
      \ 'pointer': ['fg', 'Exception'],
      \ 'marker':  ['fg', 'Keyword'],
      \ 'spinner': ['fg', 'Label'],
      \ 'header':  ['fg', 'Comment'] }

" Enable per-command history
" - History files will be stored in the specified directory
" - When set, CTRL-N and CTRL-P will be bound to 'next-history' and
"   'previous-history' instead of 'down' and 'up'.
let g:fzf_history_dir = '~/.local/share/fzf-history'

function! RipgrepFzf(query, fullscreen)
  let command_fmt = 'rg --column --line-number --no-heading --color=always --smart-case -- %s || true'
  let initial_command = printf(command_fmt, shellescape(a:query))
  let reload_command = printf(command_fmt, '{q}')
  let spec = {'options': ['--phony', '--query', a:query, '--bind', 'change:reload:'.reload_command]}
  call fzf#vim#grep(initial_command, 1, fzf#vim#with_preview(spec), a:fullscreen)
endfunction

command! -nargs=* -bang RG call RipgrepFzf(<q-args>, <bang>0)

let g:fzf_preview_window = ['right:50%', 'ctrl-\']

nmap <space>w <Cmd>Windows<CR>

" startify
let g:startify_session_number = 5
let g:startify_session_sort = 1
let g:startify_files_number = 5
let g:startify_change_to_dir = 0
let g:startify_session_delete_buffers = 0
let g:startify_change_to_vcs_root = 1

" returns all modified files of the current git repo
" `2>/dev/null` makes the command fail quietly, so that when we are not
" in a git repo, the list will be empty
function! s:gitModified()
  let files = systemlist('git ls-files -m 2>/dev/null')
  return map(files, "{'line': v:val, 'path': v:val}")
endfunction

" same as above, but show untracked files, honouring .gitignore
function! s:gitUntracked()
  let files = systemlist('git ls-files -o --exclude-standard 2>/dev/null')
  return map(files, "{'line': v:val, 'path': v:val}")
endfunction

" open list of sessions in FZF window
function! OpenSessions()
  let session_path = g:startify#get_session_path()
  try 
    let prev_action = g:fzf_action
    let g:fzf_action = {
          \ 'enter': 'source' }
    call fzf#vim#files(session_path)
  finally
    let g:fzf_action = prev_action
  endtry
endfunction

let g:startify_lists = [
      \ { 'type': 'commands',  'header': ['    Commands']       },
      \ { 'type': 'sessions',  'header': ['   󰋊 Sessions']       },
      \ { 'type': 'dir',       'header': ['   󰋚 MRU '. getcwd()] },
      \ { 'type': 'files',     'header': ['   󰋚 MRU']            },
      \ { 'type': 'bookmarks', 'header': ['    Bookmarks']      },
      \ { 'type': function('s:gitModified'),  'header': ['   󰊢 Git Modified']},
      \ ]

let figlet_message = 'CodeRabbit Neovim'
if !has('nvim')
  let figlet_message = 'CodeRabbit Vim'
endif

let g:startify_custom_header =
      \ startify#pad(split(system('figlet -w 100 '. figlet_message), "\n") + startify#fortune#boxed())

let g:startify_commands = [
      \ {'f': [' Find Files', ':Files']},
      \ {'fe': ['󰉋 Explore Files', ':CocCommand explorer --position floating']},
      \ {'s': ['󰋚 Sessions', 'call OpenSessions()']},
      \ {'b': ['󰌨 Buffers', ':Buffers']},
      \ {'w': [' Tabs & Windows', ':Windows']},
      \ {'m': [' Marks', ':Marks']},
      \ {'p': ['󰈞 Pattern', ':RG']},
      \ {'pr': [' PR List', ':Octo pr list']},
      \ {'gs': [' Git Status', ':GFiles?']},
      \ {'sa': [' Save Session', ':SSave']},
      \ {'?': ['󰋖 Cheat Sheet', ':OpenBrowser https://vim.rtorr.com']},
      \ ]

nmap <space>s <Cmd>Startify<CR>

nmap <space>f <Cmd>Files<CR>
nmap <space>p <Cmd>RG<CR>
nmap <space>b <Cmd>Buffers<CR>


" auto session management
function! GetUniqueSessionName()
  " get session name if it already exists
  let session = fnamemodify(v:this_session, ':t')
  if session ==# '__LAST__'
    let session = ''
  endif
  if !empty(session)
    return session
  endif

  let git_root = trim(system('git rev-parse --show-toplevel 2>/dev/null'))
  let path = fnamemodify(git_root, ':t')
  if empty(path)
    let path = fnamemodify(getcwd(), ':t')
  endif
  let path = empty(path) ? 'unknown' : path
  let branch = trim(system('git branch --show-current 2>/dev/null'))
  let branch = empty(branch) ? 'no-branch' : '-' . branch
  " get timestamp
  let timestamp = trim(system('date +-%Y.%m.%d.%H:%M:%S'))


  return substitute(path . branch . timestamp . '.autosave', '/', '-', 'g')
endfunction

set sessionoptions=buffers,curdir,folds,help,slash,tabpages,winsize

augroup auto_session
  autocmd VimLeavePre *             execute 'SSave! ' . GetUniqueSessionName()
augroup end

" Remove all but recent 20 files by timestamp from a directory pointed to by return value of function g:startify#get_session_path()
function! CleanupSessionFiles()
  let path = g:startify#get_session_path()
  silent call system('cd ' . path . '; ls -tp *.autosave | grep -v "/$" | tail -n +20 | tr "\n" "\0" | xargs -0 rm --')
endfunction

execute CleanupSessionFiles()

" Load startify on each new tab. Disable this if it causes any issues with
" other plugins.
augroup startify
  if has('nvim')
    autocmd TabNewEntered * 
          \ if empty(expand('%')) && empty(&l:buftype) |
          \   Startify |
          \ endif
  else
    autocmd bufwinenter *
          \ if !exists('t:startify_new_tab')
          \     && empty(expand('%'))
          \     && empty(&l:buftype)
          \     && &l:modifiable |
          \   let t:startify_new_tab = 1 |
          \   Startify |
          \ endif
  endif
augroup end

" auto close outline, diagnostics if it's open on session save
let g:startify_session_before_save = [ 
      \ 'silent! execute "lclose" | execute "cclose"',
      \ 'silent! call CocAction("hideOutline")', 
      \ 'silent! MundoHide"' 
      \ ]

function! VisualExecWithArgs(cmd, args) range
  call ExecInputValues(a:cmd, a:args, 'VisualExecInputValues')
endfunction

function! NormalExecWithArgs(cmd, args)
  call ExecInputValues(a:cmd, a:args, 'NormalExecInputValues')
endfunction

" Function that prompts the user for input values and executes a command with those values.
"
" Parameters:
"   - cmd: The command to execute with the input values.
"   - args: A list of tuples representing the input arguments. Each tuple contains the name of the argument and a boolean indicating whether it is required.
"   - exec_func: The function to execute the command with the input values.
"
" Returns: Nothing.
"
" Exceptions: If a required parameter is empty, an error message is printed and the function returns without executing the command.
function! ExecInputValues(cmd, args, exec_func)
  let arg_values = []
  if has('nvim')
    call luaeval('input_args(_A.args, _A.arg_values, _A.callback, _A.cmd)', {'args': a:args, 'arg_values': arg_values, 'callback': a:exec_func, 'cmd': a:cmd})
  else
    " Loop through each argument, prompting the user for input and adding the value to arg_values.
    for arg in a:args
      let [arg_name, required] = arg
      let value = input(arg_name . ": ")
      if required && value == ''
        echom 'Required parameter ' . arg_name . ' is empty.'
        return
      endif
      call add(arg_values, value)
    endfor
    call a:exec_func(a:cmd, arg_values)
  endif
endfunction

function! VisualExecInputValues(cmd, arg_values)
  let final_cmd = a:cmd
  for value in a:arg_values
    let final_cmd .= " " . value
  endfor
  call VisualExec(final_cmd)
endfunction

function! NormalExecInputValues(cmd, arg_values)
  let final_cmd = a:cmd
  for value in a:arg_values
    let final_cmd .= " " . value
  endfor
  execute final_cmd
endfunction

function! VisualExec(cmd) range
  if visualmode() != 'V' && visualmode() != ''
    if has('nvim')
      " select_buffer_or_cancel_nvim now accepts callback, cmd and args. 
      call luaeval('select_buffer_or_cancel(_A.callback, _A.cmd)', {'callback': 'VisualExec', 'cmd': a:cmd})
      return
    else
      let choice = inputlist(['Select entire buffer', 'Cancel'])
      if choice == 1
        normal! ggVG
        normal! \<Esc>
      else
        return
      endif
    endif
  endif

  execute a:cmd
endfunction

" FZF Menu
nmap <silent> <space><space> <Plug>(Fzm)
vmap <silent> <space><space> <Plug>(FzmVisual)
" map mouse shift+left click to Fzm
nmap <silent> <S-LeftMouse> <Plug>(Fzm)
vmap <silent> <S-LeftMouse> <Plug>(FzmVisual)

call fuzzymenu#Reset()

let g:fuzzymenu_auto_add = 0

" fzf mappings
call fuzzymenu#AddAll({
      \ '󰋜 Main Menu': {'exec': 'Startify'},
      \ ' Find Files': {'exec': 'Files'},
      \ ' Git Files': {'exec': 'GFiles'},
      \ 'ﮦ Sessions': {'exec': 'call OpenSessions()'},
      \ ' Save Session': {'exec': 'SSave'},
      \ ' Colors': {'exec': 'Colors'},
      \ ' Lines': {'exec': 'BLines'},
      \ '󰌨 Buffers': {'exec': 'Buffers'},
      \ ' Tabs & Windows': {'exec': 'Windows'},
      \ ' Marks': {'exec': 'Marks'},
      \ '󰈞 Pattern': {'exec': 'RG'},
      \ ' Filetypes': {'exec': 'Filetypes'},
      \ ' Commands': {'exec': 'Commands'},
      \ ' Key Maps': {'exec': 'Maps'},
      \ ' Snippets': {'exec': 'Snippets'},
      \ ' Help Tags': {'exec': 'Helptags'},
      \ ' Command History': {'exec': 'History:'},
      \ ' Search History': {'exec': 'History/'},
      \ ' Terminals': {'exec': 'Floaterms'},
      \ ' Undotree': {'exec': 'MundoToggle'},
      \ ' IndentLines': {'exec': 'IndentLinesToggle'},
      \ ' ANSI Escape': {'exec': 'AnsiEsc'},
      \ ' Update Plugins': {'exec': 'PlugUpdate'},
      \ ' Update Coc Extensions': {'exec': 'CocUpdate'},
      \ ' Unicode Symbols': {'exec': 'call unicode#Fuzzy()'},
    \ },
    \ {'after': 'call fuzzymenu#InsertModeIfNvim()', 'tags': ['tools']})

" Coc menu
call fuzzymenu#AddAll({
      \ ' Diagnostics (Workspace)': {'exec': 'CocFzfList diagnostics'},
      \ ' Diagnostics (Buffer)': {'exec': 'call ToggleDiagnostics()'},
      \ ' Coc Actions': {'exec': 'call CocActionAsync("codeAction")'},
      \ ' Coc Commands': {'exec': 'CocCommand'},
      \ '󰌵 CodeLens Actions': {'exec': 'call CocActionAsync("codeLensAction")'},
      \ '󰉼 Format': {'exec': 'CocCommand editor.action.formatDocument'},
      \ '󰉋 File Explorer': {'exec': 'CocCommand explorer'},
      \ '󰈈 Outline Sidebar': {'exec': 'call OutlineToggle()'},
      \ '󰅴 Goto Definition': {'exec': 'call CocActionAsync("jumpDefinition")'},
      \ '󰅴 Goto Implementation': {'exec': 'call CocActionAsync("jumpImplementation")'},
      \ '󰅴 Goto References': {'exec': 'call CocActionAsync("jumpReferences")'},
      \ '󱖖 Incoming Calls': {'exec': 'CocCommand document.showIncomingCalls'},
      \ '󱖔 Outgoing Calls': {'exec': 'CocCommand document.showOutgoingCalls'},
      \ ' Documentation': {'exec': 'call ShowDocumentation()'},
      \ ' Coc Lists': {'exec': 'CocFzfList'},
      \ '󰐱 Coc Extensions': {'exec': 'CocFzfList extensions'},
      \ '󰣖 Coc Services': {'exec': 'CocFzfList services'},
      \ ' Coc Config': {'exec': 'CocConfig'},
      \ '󰜉 Coc Restart': {'exec': 'CocRestart'},
      \ '󰣖 Coc Completion Sources': {'exec': 'CocFzfList sources'},
      \ ' Coc LSP Logs': {'exec': 'CocCommand workspace.showOutput'},
      \ ' Coc Logs': {'exec': 'CocInfo'},
      \ '󰈈 Outline Navigator': {'exec': 'CocFzfList outline'},
      \ '󰑕 Rename': {'exec': 'CocRename'},
      \ ' Organize Imports': {'exec': 'CocCommand editor.action.organizeImport'},
      \ '󰆒 Yank History (Clipboard)': {'exec': 'CocFzfList yank'},
      \ '󰈙 Render Swagger/OpenAPI spec': {'exec': 'CocCommand swagger.render'},
      \ '󰊤 GitHub Browser': {'exec': 'GBrowse'},
    \ },
    \ {'tags': ['coc'],
    \ 'for': {'exists': 'g:coc_enabled'}})

call fuzzymenu#AddAll({
      \ ' Markdown Preview': {'exec': 'CocCommand markdown-preview-enhanced.openPreview'}, 
      \ ' Markdown Map': {'exec': 'CocCommand markmap.watch'}, 
      \ ' Markdown Generate Slides': {'exec': 'CocCommand reveal.it'}, 
      \ },
      \ {'for': {'ft': 'md', 'exists': 'g:coc_enabled'}, 'tags': ['markdown', 'coc']})

call fuzzymenu#AddAll({
        \ '󰟓 AddTags Struct': {'exec': 'CocCommand go.tags.add.prompt'},
        \ '󰟓 AddTags Line': {'exec': 'CocCommand go.tags.add.line'},
        \ '󰟓 ClearTags Struct': {'exec': 'CocCommand go.tags.clear'},
        \ '󰟓 ClearTags Line': {'exec': 'CocCommand go.tags.clear.line'},
        \ '󰟓 RemoveTags Struct': {'exec': 'CocCommand go.tags.remove.prompt'},
        \ '󰟓 RemoveTags Line': {'exec': 'CocCommand go.tags.remove.line'},
        \ '󰟓 Generate Tests Exported': {'exec': 'CocCommand go.tests.generate.exported'},
        \ '󰟓 Generate Tests File': {'exec': 'CocCommand go.tests.generate.file'},
        \ '󰟓 Generate Tests Function': {'exec': 'CocCommand go.tests.generate.function'},
        \ '󰟓 Mod Tidy': {'exec': 'CocCommand go.gopls.tidy'},
        \ '󰟓 Generate Interface': {'exec': 'CocCommand go.impl.cursor'},
        \ '󰟓 Play (launch in browser)': {'exec': 'CocCommand go.playground'},
        \ '󰟓 Toggle Test/Code': {'exec': 'CocCommand go.test.toggle'},
      \ },
      \ {'for': {'ft': 'go', 'exists': 'g:coc_enabled'}, 'tags':['go', 'coc']})

call fuzzymenu#Add(' Setup GitHub Copilot', {'normal': ':Copilot setup'}, {'tags': ['github']})
call fuzzymenu#Add(' GitHub Copilot Solutions', {'exec': 'Copilot panel'}, {'tags': ['github']})

call fuzzymenu#AddAll({
  \ ' Diff (git diff)': {'exec': 'Gdiffsplit'},
  \ ' Blame (git blame)': {'exec': 'Git blame'},
  \ '󱓍 Read (git checkout)': {'exec': 'Gread'},
  \ '󱣪 Write (git add)': {'exec': 'Gwrite'},
  \ '󰆴 Delete (git rm)': {'exec': 'GDelete'},
  \ '󰜘 Commit (git commit)': {'exec': 'Git commit'},
  \ '󰓂 Pull (git pull)': {'exec': 'Git pull'},
  \ '󰘭 Push (git push)': {'exec': 'Git push'},
  \ '󰳐 Commits (git log)': {'exec': 'BCommits'},
  \ ' Status (git status)': {'exec': 'GFiles?'},
  \ ' Stash (git stash)': {'exec': 'GStashList'},
  \ },
  \ {'for': {'exists': 'g:loaded_fugitive'}, 'tags': ['git']})

call fuzzymenu#Add(' Mergetool', {'exec': 'MergetoolToggle'}, {'tags': ['mergetool']})
call fuzzymenu#AddAll({
  \ ' Mergetool Layout Merge, Remote': {'exec': 'MergetoolToggleLayout mr'},
  \ ' Mergetool Layout Base, Merge, Remote': {'exec': 'MergetoolToggleLayout mr,b'},
  \ ' Mergetool Exchange Left': {'exec': 'MergetoolDiffExchangeLeft'},
  \ ' Mergetool Exchange Right': {'exec': 'MergetoolDiffExchangeRight'},
  \ ' Mergetool Exchange Down': {'exec': 'MergetoolDiffExchangeDown'},
  \ ' Mergetool Exchange Up': {'exec': 'MergetoolDiffExchangeUp'},
  \ ' Mergetool Prefer Local': {'exec': 'MergetoolPreferLocal'},
  \ ' Mergetool Prefer Remote': {'exec': 'MergetoolPreferRemote'},
  \ },
  \ {'for': {'exists': 'g:merging'}, 'tags': ['mergetool']})

" Octo
if has('nvim')
  call fuzzymenu#AddAll({
    \ ' PR List': {'exec': 'Octo pr list'},
    \ ' PR Search': {'exec': 'Octo pr search'},
    \ ' Gist List': {'exec': 'Octo gist list'},
    \ '󰊤 GitHub Search': {'exec': 'Octo search'},
    \ '󰊤 Issues List': {'exec': 'Octo issue list'},
    \ '󰊤 Issues Search': {'exec': 'Octo issue search'},
    \ '󰊤 Octo': {'exec': 'Octo actions'},
    \ },
    \ {'tags': ['octo', 'github']})
endif

" vim cheat-sheet link
call fuzzymenu#Add(' Vim Cheat-sheet (Browser)', {'exec': 'OpenBrowser https://vim.rtorr.com'}, {'tags': ['vim']})

" basic options
call fuzzymenu#Add(' Case-sensitive searches', {'exec': 'set noignorecase'}, {'tags': ['vim']})
call fuzzymenu#Add(' Case-insensitive searches', {'exec': 'set ignorecase'}, {'tags': ['vim']})
call fuzzymenu#Add(' Hide line numbers', {'exec': 'set nonumber'}, {'tags': ['vim']})
call fuzzymenu#Add(' Show line numbers', {'exec': 'set number'}, {'tags': ['vim']})
call fuzzymenu#Add(' Hide whitespace characters', {'exec': 'set nolist'}, {'tags': ['vim']})
call fuzzymenu#Add(' Show whitespace characters', {'exec': 'set list'}, {'tags': ['vim']})
call fuzzymenu#Add(' Undo', {'normal': 'u'}, {'tags': ['vim']})
call fuzzymenu#Add(' Redo', {'normal': "\<c-r>"}, {'tags': ['vim']})
call fuzzymenu#Add(' Quit (exit) all', {'exec': 'qa'}, {'tags': ['vim']})
call fuzzymenu#Add(' Quit (exit) all without saving', {'exec': 'qa!'}, {'tags': ['vim']})
call fuzzymenu#Add(' Write (save) and quit (exit) all', {'exec': 'wqa'}, {'tags': ['vim']})
call fuzzymenu#Add(' Write (save) current buffer', {'exec': 'w'}, {'tags': ['vim']})
call fuzzymenu#Add(' Write (save) all', {'exec': 'wa'}, {'tags': ['vim']})

" common editor features
call fuzzymenu#Add(' New Tab', {'exec': 'tabnew'}, {'tags': ['vim']})
call fuzzymenu#Add(' Close Window', {'exec': 'close'}, {'tags': ['vim']})
call fuzzymenu#Add(' New buffer', {'exec': 'new'}, {'tags': ['vim']})
call fuzzymenu#Add(' Delete buffer (close file)', {'exec': 'bd'}, {'tags': ['vim']})
call fuzzymenu#Add(' Delete buffer (close file) WITHOUT saving', {'exec': 'bd!'}, {'tags': ['vim']})
call fuzzymenu#Add(' Vertical split', {'exec': 'vs'}, {'tags': ['vim']})
call fuzzymenu#Add(' Horizontal split', {'exec': 'sp'}, {'tags': ['vim']})
call fuzzymenu#Add(' Select all', {'normal': 'ggVG'}, {'tags': ['vim']})
call fuzzymenu#Add(' Find word under cursor', {'normal': '*'}, {'tags': ['vim']})
call fuzzymenu#Add(' Next match', {'normal': 'n'}, {'tags': ['vim']})
call fuzzymenu#Add(' Previous match', {'normal': 'N'}, {'tags': ['vim']})
call fuzzymenu#Add(' Repeat (last normal mode operation)', {'normal': '.'}, {'tags': ['vim']})
call fuzzymenu#Add(' Repeat (last :command)', {'normal': '@:'}, {'tags': ['vim']})
call fuzzymenu#Add(' Open file under cursor', {'normal': 'gf'}, {'tags': ['vim']})
call fuzzymenu#Add(' Browse to link under cursor', {'normal': 'gx'}, {'tags': ['vim']})
call fuzzymenu#Add(' Jumps', {'exec': 'jumps'}, {'tags': ['vim']})
call fuzzymenu#Add(' Jump Next', {'normal': "\<c-i>"}, {'tags': ['vim']})
call fuzzymenu#Add(' Jump Back', {'normal': "\<c-o>"}, {'tags': ['vim']})

" normal mode for incomplete functions
call fuzzymenu#Add(' Find', {'normal': '/'}, {'tags': ['vim']})

call fuzzymenu#Add(' Next match', {'normal': 'n'}, {'tags': ['vim']})
call fuzzymenu#Add(' Previous match', {'normal': 'N'}, {'tags': ['vim']})
call fuzzymenu#Add(' Replace next match', {'normal': ':s//'}, {'tags': ['vim']})
call fuzzymenu#Add(' Replace in file', {'normal': ':%s//'}, {'tags': ['vim']})
call fuzzymenu#Add(' Replace in open buffers', {'normal': ':bufdo :%s//'}, {'tags': ['vim']})

call fuzzymenu#Add(' Put (paste)', {'normal': 'p'}, {'tags': ['vim']})

" Telescope enabled options
if has("nvim")
  call fuzzymenu#Add(' Tag Stack', {'exec': 'Telescope tagstack'}, {'tags': ['vim']})
  call fuzzymenu#Add(' Old Files', {'exec': 'Telescope oldfiles'}, {'tags': ['tools']})
  call fuzzymenu#Add(' Vim Options', {'exec': 'Telescope vim_options'}, {'tags': ['tools']})
  call fuzzymenu#Add(' Man Pages', {'exec': 'Telescope man_pages'}, {'tags': ['tools']})
  call fuzzymenu#Add(' Symbols/Emojis', {'exec': 'Telescope symbols'}, {'tags': ['tools']})
  call fuzzymenu#Add('󰎟 Notification Center', {'exec': 'Telescope notify'}, {'tags': ['tools']})
  call fuzzymenu#Add(' AutoSave Toggle', {'exec': 'ASToggle'}, {'tags': ['tools']})
  call fuzzymenu#Add(' Run Shell Command', {'exec': ':call NormalExecWithArgs("Sh", [["Command", 1]])'}, {'tags': ['tools']})
  call fuzzymenu#Add(' Make Target', {'exec': ':call SelectMakeTarget()'}, {'tags': ['tools']})
  call fuzzymenu#Add(' Send Text to Terminal', {'exec': ':lua tmux.send_text_to()'}, {'tags': ['tmux']})
  call fuzzymenu#Add(' Switch tmux Orientation', {'exec': ':lua tmux.switch_orientation()'}, {'tags': ['tmux']})
  call fuzzymenu#Add(' Switch tmux Open As', {'exec': ':lua tmux.switch_open_as()'}, {'tags': ['tmux']})
  call fuzzymenu#Add(' Kill All tmux Terms', {'exec': ':lua tmux.kill_all_terms()'}, {'tags': ['tmux']})
  call fuzzymenu#Add(' Run Project tmux Terms', {'exec': ':lua tmux.run_project_terms()'}, {'tags': ['tmux']})
  call fuzzymenu#Add(' List All tmux Terms', {'exec': 'Telescope tmux-awesome-manager list_terms'}, {'tags': ['tmux']})
  call fuzzymenu#Add(' List Open tmux Terms', {'exec': 'Telescope tmux-awesome-manager list_open_terms'}, {'tags': ['tmux']})
  call fuzzymenu#Add(' Git Ship', {'exec': ':lua tmux.execute_command( { cmd = "git_ship; echo; echo; echo Done", name = "Git Ship" })'}, {'tags': ['tools']})
else
  call fuzzymenu#Add(' Tag Stack', {'exec': 'tags'}, {'tags': ['tools']})
endif
  if exists('$OPENAI_API_KEY') && has("nvim")
    call fuzzymenu#Add('󰚩 ChatGPT Chat', {'exec': ':call NormalExecWithArgs("Chat", [["Instructions", 1]])'}, {'tags': ['chatgpt']})
    " ChatGPT visual selection
    call fuzzymenu#AddAll({
      \ '󰚩 ChatGPT Completion': {'visual': ':call VisualExec("Chat completion")' },
      \ '󰚩 ChatGPT Explain': {'visual': ':call VisualExec("Chat explain")' },
      \ '󰚩 ChatGPT Debug': {'visual': ':call VisualExec("Chat debug")' },
      \ '󰚩 ChatGPT Document': {'visual': ':call VisualExec("Chat doc")' },
      \ '󰚩 ChatGPT Optimize': {'visual': ':call VisualExec("Chat opt")' },
      \ '󰚩 ChatGPT Add Tests': {'visual': ':call VisualExec("Chat tests")' },
      \ '󰚩 ChatGPT Refactor': {'visual': ':call VisualExec("Chat refactor")' },
      \ '󰚩 ChatGPT Simplify': {'visual': ':call VisualExec("Chat simplify")' },
      \ '󰚩 ChatGPT Fix': {'visual': ':call VisualExec("Chat fix")' },
      \ '󰚩 ChatGPT Summarize': {'visual': ':call VisualExec("Chat summarize")' },
      \ '󰚩 ChatGPT Grammar': {'visual': ':call VisualExec("Chat grammer")' },
      \ '󰚩 ChatGPT Question': {'visual': ':call VisualExecWithArgs("Chat question", [["Question", 1]])' },
      \ '󰚩 ChatGPT Edit With Instructions': {'visual': ':call VisualExecWithArgs("Chat code_edit", [["Instructions", 1]])' },
      \ },
      \ {'tags': ['visual','chatgpt']})
  endif

" normal mode operators (For text objects) 

" Comment/Uncomment (gc)
" override gcgc to do single line comment/uncomment to make it consistent with
" other vim commands
nmap gcgc <Plug>CommentaryLine

let ops = {}
let ops[' Comment/Uncomment'] = { 'exec': 'FzmOp gc' }

for i in items(fuzzymenu#operators#Get())
    let name = ' ' . i[1]
    let op = i[0]
    let ops[name] = { 'exec': 'FzmOp '.op }
endfor
call fuzzymenu#AddAll(ops,
    \ {'after': 'call fuzzymenu#InsertModeIfNvim()', 'tags': ['normal','vim']})

let ops = {}
let ops[' Comment/Uncomment'] = { 'visual': 'gc' }
for i in items(fuzzymenu#operators#Get())
    let name = ' ' . i[1]
    let op = i[0]
    "" remove 'g' prefix from uppercase/lowercase/format/...
    let op = substitute(op, '^g', '', '')
    let ops[name] = { 'visual': op }
endfor

call fuzzymenu#AddAll(ops,
    \ {'tags': ['visual','vim']})

call fuzzymenu#Add(' Operators (text objects and motions)', {
      \ 'exec': 'FzmOps'}, {
      \ 'after': 'call fuzzymenu#InsertModeIfNvim()', 
      \ 'tags': ['normal','vim']
      \})

call fuzzymenu#AddAll({
      \' Apply setting (persist)': { 'exec': 'call fuzzymenu#vimconfig#ApplySetting(1)'}, 
      \' Apply setting (temporary)': { 'exec': 'call fuzzymenu#vimconfig#ApplySetting(0)'}, 
      \' Create a key mapping (persist)': { 'exec': 'call fuzzymenu#vimconfig#MapKey({})' },
      \ },
      \ { 'after': 'call fuzzymenu#InsertModeIfNvim()', 'tags': ['misc']})

" Maintain undo history between sessions
if has("nvim")
  set undodir=~/.local/share/nvim/undodir
else 
  set undodir=~/.vim/undodir
endif

" mkdir undodir if it doesn't exist
if !isdirectory(expand($undodir))
  silent call system('mkdir ' . $undodir)
endif

set undofile
set undolevels=1000
set undoreload=10000

nmap <space>u <Cmd>MundoToggle<CR>

" Floaterms
let g:ft_float_width = 0.9
let g:ft_float_height = 0.9
let g:ft_window_height = 0.25
let g:ft_window_width = 0.25

let g:fzf_floaterm_newentries = {
  \ '+root' : {
    \ 'title': 'Root Shell (floating)',
    \ 'width': g:ft_float_width,
    \ 'height': g:ft_float_height,
    \ 'cmd': 'sudo sh' },
  \ '+zsh' : {
    \ 'title': 'Zsh Shell (floating)',
    \ 'width': g:ft_float_width,
    \ 'height': g:ft_float_height,
    \ 'cmd': 'zsh' },
  \ '+root-tab' : {
    \ 'title': 'Root Shell (bottom window)',
    \ 'height': g:ft_window_height,
    \ 'wintype': 'split',
    \ 'cmd': 'sudo sh' },
  \ '+zsh-tab' : {
    \ 'title': 'Zsh Shell (bottom window)',
    \ 'height': g:ft_window_height,
    \ 'wintype': 'split',
    \ 'cmd': 'zsh' },
  \ }

let g:floaterm_autohide = 2

nmap <space>t <Cmd>Floaterms<CR>

let g:floaterm_title = ' Floaterm'
autocmd FileType floaterm tnoremap <expr> <ESC> (&filetype == "floaterm") ? "<C-\><C-n>:FloatermHide<CR>" : "<ESC>"

" openbrowser
let g:netrw_nogx = 1 " disable netrw's gx mapping.
nmap gx <Plug>(openbrowser-smart-search)
vmap gx <Plug>(openbrowser-smart-search)


" Mergetool
let g:mergetool_layout = 'mr'
let g:mergetool_prefer_revision = 'local'

function s:QuitMergetool()

  " If we're in merge mode, exit
  if get(g:, 'mergetool_in_merge_mode', 0)
    call mergetool#stop()
    return
  endif

endfunction

autocmd VimLeavePre * call s:QuitMergetool()

function s:MergeToolBufEnter()
  if get(g:, 'mergetool_in_merge_mode', 0)
    let g:merging = 1
  endif
endfunction

function s:MergeToolBufLeave()
  if exists('g:merging')
    unlet g:merging
  endif
endfunction

autocmd BufEnter * call s:MergeToolBufEnter()
autocmd BufLeave * call s:MergeToolBufLeave()

" colorschemes
let colorscheme = 'gruvbox_dark'

" some some defaults
let g:gruvbox_material_better_performance = 1
let g:gruvbox_material_diagnostic_text_highlight = 1
let g:gruvbox_material_diagnostic_virtual_text = 'colored'

let g:everforest_better_performance = 1
let g:edge_better_performance = 1
let g:sonokai_better_performance = 1

" source ~/.vimrc_local for local overrides
if filereadable(expand('~/.vimrc_local'))
  source ~/.vimrc_local
endif

function! s:SetHighlights()
  " set codelens color
  hi CocCodeLens guifg=Orange gui=Italic
endfunction

autocmd ColorScheme * call s:SetHighlights()

" set colorscheme based on colorscheme variable
if colorscheme == 'gruvbox_dark'
  set background=dark
  colorscheme gruvbox-material
elseif colorscheme == 'gruvbox_light'
  set background=light
  colorscheme gruvbox-material
elseif colorscheme == 'iceberg_dark'
  set background=dark
  colorscheme iceberg
elseif colorscheme == 'iceberg_light'
  set background=light
  colorscheme iceberg
elseif colorscheme == 'everforest_dark'
  set background=dark
  colorscheme everforest
elseif colorscheme == 'everforest_light'
  set background=light
  colorscheme everforest
elseif colorscheme == 'edge_dark'
  set background=dark
  colorscheme edge
elseif colorscheme == 'edge_light'
  set background=light
  colorscheme edge
elseif colorscheme == 'sonokai_dark'
  set background=dark
  colorscheme sonokai
elseif colorscheme == 'sonokai_light'
  set background=light
  colorscheme sonokai
elseif colorscheme != ''
  try
    execute 'colorscheme '.colorscheme
  catch
    echohl WarningMsg | echom 'Unable to find colorscheme: ' . colorscheme . ' defaulting to gruvbox-material' | echohl None
    set background=dark
    colorscheme gruvbox-material
  endtry
endif

" check whether &guifont is empty
if &guifont == ''
  if has('macunix')
    silent! set guifont=Hack_Regular_Nerd_Font_Complete_Mono:h15
  else
    if has("nvim")
      silent! set guifont=Hack\ Nerd\ Font\ Mono:h15
    else
      silent! set guifont=Hack\ Nerd\ Font\ Mono\ 15
    endif
  endif
endif
